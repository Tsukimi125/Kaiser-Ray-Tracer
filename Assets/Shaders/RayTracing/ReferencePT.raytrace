#include "UnityShaderVariables.cginc"
#include "includes/RayPayload.hlsl"
#include "includes/Utils.hlsl"
#include "includes/Global.hlsl"
#include "includes/Lighting.hlsl"
#include "includes/BRDF/BRDF.hlsl"
#include "includes/rt/RayTrace.hlsl"

uint g_ConvergenceStep;
uint g_FrameIndex;
float g_Zoom;
float g_AspectRatio;

uint g_SamplePerPixel;

int g_Progressive;

TextureCube<float4> g_EnvTex;
SamplerState sampler_g_EnvTex;

#pragma max_recursion_depth 10


float3 tracePath(uint2 launchIndex, uint2 launchDim)
{
    float2 frameCoord = launchIndex + float2(0.5, 0.5);
    float3 result = float3(0, 0, 0);
    
    uint rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(g_ConvergenceStep + g_FrameIndex) * uint(26699)) | uint(1);
    float2 jitter = float2(RandomFloat01(rng), RandomFloat01(rng)) - float2(0.5, 0.5);
    float2 ndcCoords = (frameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);
    
    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    // Get a ray in view space.
    float3 viewDirection = normalize(float3(ndcCoords.x * g_AspectRatio, ndcCoords.y, 1));

    // Rotate the ray from view space to world space.
    float3 rayDirection = mul((float3x3)unity_CameraToWorld, viewDirection);

    RayDesc ray = CreateNewRay(_WorldSpaceCameraPos, rayDirection, 0, 9999);

    // TODO: RayCone Never Used
    RayCone rayCone = RayCone::Create(launchDim.y, 0.0);
    
    float3 throughput = 1.0.xxx;
    float3 radiance = 0.0.xxx;
    uint pathlength = 0;
    

    PathVertex hitVertex = KaiserRayTracer::Create(ray, rayCone, pathlength, false).Trace(g_AccelStruct);

    if (hitVertex.bHit)
    {
        return hitVertex.surfaceData.normal;
    }
    return 0.0.xxx;
}


[shader("raygeneration")]
void PathTracingRayGenShader()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;

    float3 result = tracePath(launchIndex, launchDim);

    float3 prevRadiance = g_Output[launchIndex].xyz;
    if (g_Progressive == 1) result = lerp(prevRadiance, result, 1 / float(g_ConvergenceStep + 1));

    g_Output[launchIndex] = float4(result, 1);
}

[shader("miss")]
void MissShader0_Primary(inout RayPayload payload : SV_RayPayload)
{
    // payload.emission = 0;
    // // payload.emission = g_EnvTex.SampleLevel(sampler_g_EnvTex, WorldRayDirection(), 0).xyz;
    
    // payload.bounceIndexOpaque = -1;

}
