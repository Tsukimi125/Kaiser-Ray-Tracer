#include "UnityShaderVariables.cginc"
#include "includes/RayPayload.hlsl"
#include "includes/Utils.hlsl"
#include "includes/Global.hlsl"
#include "includes/Lighting.hlsl"
#include "includes/BRDF/BRDF.hlsl"
#include "includes/rt/RayTrace.hlsl"

uint g_ConvergenceStep;
uint g_FrameIndex;
float g_Zoom;
float g_AspectRatio;

uint g_SamplePerPixel;

int g_Progressive;

TextureCube<float4> g_EnvTex;
SamplerState sampler_g_EnvTex;

#pragma max_recursion_depth 10



float3 tracePath(uint2 launchIndex, uint2 launchDim)
{
    float2 frameCoord = launchIndex + float2(0.5, 0.5);
    float3 result = float3(0, 0, 0);
    
    uint rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(g_ConvergenceStep + g_FrameIndex) * uint(26699)) | uint(1);
    float2 jitter = float2(RandomFloat01(rng), RandomFloat01(rng)) - float2(0.5, 0.5);
    float2 ndcCoords = (frameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);
    
    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    // Get a ray in view space.
    float3 viewDirection = normalize(float3(ndcCoords.x * g_AspectRatio, ndcCoords.y, 1));

    // Rotate the ray from view space to world space.
    float3 rayDirection = mul((float3x3)unity_CameraToWorld, viewDirection);

    float3 throughput = 1.0.xxx;
    float3 radiance = 0.0.xxx;
    float3 totalRadiance = 0.0.xxx;

    RayDesc ray;
    {
        ray = CreateNewRay(_WorldSpaceCameraPos, rayDirection, K_T_MIN, K_T_MAX);
    }
    
    [loop]
    for (uint pathLength = 0; pathLength < g_BounceCountOpaque; pathLength++)
    {
        // TODO: RayCone Never Used
        RayCone rayCone = RayCone::Create(launchDim.y, 0.0);

        PathVertex hitVertex = KaiserRayTracer::Create(ray, rayCone, pathLength, false).Trace(g_AccelStruct);

        if (!hitVertex.bHit)
        {
            break;
        }

        SurfaceData surfaceData = hitVertex.surfaceData;

        // if (dot(surfaceData.normal, ray.Direction) >= 0.0)
        // {
        //     if (0 == pathLength)
        //     {
        //         // Flip the normal for primary hits so we don't see blackness
        //         surfaceData.normal = -surfaceData.normal;
        //     }
        //     else
        //     {
        //         break;
        //     }
        // }

        const bool isShadowed = KaiserRayTracer::Create(CreateNewRay(hitVertex.position, _DirectionalLightDirection, 1e-4, K_T_MAX), rayCone, pathLength, false).TraceShadowRay(g_AccelStruct);

        const float3x3 tangentToWorld = BuildOrthonormalBasis(surfaceData.normal);
        float3 wo = mul(-ray.Direction, tangentToWorld);
        // float3 wo = mul(-outgoing_ray.Direction, tangent_to_world);
        const float3 wi = mul(_DirectionalLightDirection, tangentToWorld);

        if (wo.z < 0.0)
        {
            wo.z *= -0.25;
            wo = normalize(wo);
        }

        LayeredBRDF brdf = LayeredBRDF::Create(surfaceData, wo.z);
        BRDFValue brdfValue = brdf.diffuseBRDF.evaluate(wo, wi);

        radiance += SELECT(isShadowed, 0.0, throughput * brdfValue.value * _DirectionalLightColor * max(0.0, wi.z));
        // radiance += throughput * brdfValue.value * _DirectionalLightColor * max(0.0, wi.z);
        radiance += throughput * surfaceData.emissive;
        // radiancePack[pathLength] = throughput * brdfValue.value * _DirectionalLightColor * max(0.0, wi.z);

        float3 urand;

        #ifdef USE_NEW_RANDOM_SYSTEM
            // TODO: USE_NEW_RANDOM_SYSTEM
        #else
            urand = float3(RandomFloat01(rng), RandomFloat01(rng), RandomFloat01(rng));
        #endif
        
        BRDFSample brdfSample = BRDFSample::invalid();
        brdfSample = brdf.diffuseBRDF.sample(wo, urand.xy);

        if (brdfSample.IsValid())
        {
            ray.Origin = hitVertex.position;
            ray.Direction = mul(tangentToWorld, brdfSample.wi);
            ray.TMin = 1e-4;
            throughput *= brdfSample.valueOverPDF;
        }
        else
        {
            break;
        }

        // Russian roulette
        if (pathLength >= 2)
        {
            const float rr_coin = RandomFloat01(rng);
            const float continue_p = max(surfaceData.albedo.r, max(surfaceData.albedo.g, surfaceData.albedo.b));
            if (rr_coin > continue_p)
            {
                break;
            }
            else
            {
                throughput /= continue_p;
            }
        }
        if (all(radiance >= 0.0))
        {
            totalRadiance += float4(radiance, 1.0);
        }
    }
    return totalRadiance.rgb;
}


[shader("raygeneration")]
void PathTracingRayGenShader()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;

    float3 result = tracePath(launchIndex, launchDim);

    float3 prevRadiance = g_Output[launchIndex].xyz;
    if (g_Progressive == 1) result = lerp(prevRadiance, result, 1 / float(g_ConvergenceStep + 1));

    g_Output[launchIndex] = float4(result, 1);
}

[shader("miss")]
void MissShader0_Primary(inout RayPayload payload : SV_RayPayload)
{
    // payload.emission = 0;
    // // payload.emission = g_EnvTex.SampleLevel(sampler_g_EnvTex, WorldRayDirection(), 0).xyz;
    
    // payload.bounceIndexOpaque = -1;

}
[shader("miss")]
void MissShader1_ShadowRay(inout ShadowRayPayload payload : SV_RayPayload)
{
    payload.isShadowed = false;
}
