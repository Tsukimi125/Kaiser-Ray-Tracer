#include "UnityShaderVariables.cginc"
#include "../ShaderLibrary/RayPayload.hlsl"
#include "../ShaderLibrary/Utils/RayTracingHelper.hlsl"
#include "../ShaderLibrary/Utils/Random.hlsl"
#include "../ShaderLibrary/Utils/MathConstant.hlsl"
#include "../ShaderLibrary/RayTracingGlobal.hlsl"
#include "../ShaderLibrary/Lighting.hlsl"
#include "../ShaderLibrary/BRDF/BRDF.hlsl"
#include "../ShaderLibrary/rt/RayTrace.hlsl"
#include "../ShaderLibrary/ReSTIR/Reservoir.hlsl"
// #include "../ShaderLibrary/Utils/SpaceTransforms.hlsl"

#pragma max_recursion_depth 10

#define K_USE_ROUGHNESS_BIAS 0

// Ray Tracing Properties
uint _PT_ConvergenceStep;
uint _PT_FrameIndex;
uint _PT_MaxFrameCount;
int _PT_Progressive;

// Camera Properties
float _PT_Zoom;
float _PT_AspectRatio;

// Environment Properties
TextureCube<float4> _PT_EnvTex;
SamplerState sampler_PT_EnvTex;
float _PT_EnvIntensity;

// GBuffers
Texture2D<float4> _GBuffer0;
Texture2D<float4> _GBuffer1;
Texture2D<float4> _GBuffer2;
Texture2D<float4> _GBuffer3;

RWTexture2D<int4> _TReservoir;


void TraceShadowRay(in PathVertex hitVertex, inout TraceData trace, inout VertexData vertex)
{
    // Trace shadow ray
    const bool isShadowed = KaiserRayTracer::Create(CreateNewRay(hitVertex.position, _DirectionalLightDirection, 1e-4, K_T_MAX), trace.pathLength, false).TraceShadowRay(_AccelStruct);
    trace.firstLuminance = SELECT(isShadowed, 0.0, vertex.brdf.evalDirectionalLight(vertex.wo, vertex.wi) * _DirectionalLightColor);
    trace.radiance += trace.throughput * trace.firstLuminance;
}


bool TraceScatterRay(inout RayDesc ray, inout PathVertex hitVertex, inout TraceData trace, inout VertexData vertex, inout uint rng)
{
    float3 urand;
    urand = float3(RandomFloat01(rng), RandomFloat01(rng), RandomFloat01(rng));
    
    BRDFSample brdfSample = BRDFSample::Invalid();
    brdfSample = vertex.brdf.sample(urand, vertex.wo);
    trace.invPDF = 1.0 / brdfSample.pdf;

    if (brdfSample.IsValid())
    {
        ray.Origin = ComputeRayOrigin(hitVertex.position, hitVertex.surfaceData.normal);;
        ray.Direction = mul(vertex.tangentToWorld, brdfSample.wi);
        ray.TMin = 1e-4;
        trace.throughput *= brdfSample.weight;
    }
    else
    {
        return false;
    }
    
    hitVertex = KaiserRayTracer::Create(ray, 0, false).TraceScatterRay(_AccelStruct);

    if (!hitVertex.bHit)
    {
        trace.radiance += trace.throughput * _PT_EnvIntensity * _PT_EnvTex.SampleLevel(sampler_PT_EnvTex, ray.Direction, 0).rgb;
        return false;
    }

    if (dot(hitVertex.surfaceData.normal, ray.Direction) >= 0.0)
    {
        if (0 == trace.pathLength)
        {
            hitVertex.surfaceData.normal = -hitVertex.surfaceData.normal;
        }
        else
        {
            return false;
        }
    }
    trace.radiance += trace.throughput * hitVertex.surfaceData.emission;
    return true;
}


void TracePath(uint2 launchIndex, uint2 launchDim, inout uint rng, inout TraceData trace, inout VertexData vertex)
{
    float2 frameCoord = launchIndex + float2(0.5, 0.5);
    float3 result = float3(0, 0, 0);
    
    // uint rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(_PT_ConvergenceStep + _PT_FrameIndex) * uint(24699)) | uint(1);
    float2 jitter = float2(RandomFloat01(rng), RandomFloat01(rng)) - float2(0.5, 0.5);
    float2 uv = frameCoord / float2(launchDim.x - 1, launchDim.y - 1);
    // float2 uv = (frameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);

    trace.pathLength = 0;
    trace.throughput = float3(1, 1, 1);
    trace.radiance = float3(0, 0, 0);
    trace.firstLuminance = float3(0, 0, 0);

    
    float3 albedo = _GBuffer0.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 normal = _GBuffer1.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 worldPos = _GBuffer2.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 rmao = _GBuffer3.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float roughness = rmao.x;
    float metallic = rmao.y;

    SurfaceData surfaceData;
    surfaceData.albedo = albedo;
    surfaceData.normal = normal;
    surfaceData.emission = float3(0, 0, 0);
    // surfaceData.roughness = roughness;
    // surfaceData.metallic = metallic;
    surfaceData.roughness = 0.999;
    surfaceData.metallic = 0.001;

    float3 viewDir = normalize(_WorldSpaceCameraPos - worldPos);

    vertex.tangentToWorld = BuildOrthonormalBasis(surfaceData.normal);
    vertex.wo = mul(viewDir, vertex.tangentToWorld);
    vertex.wi = mul(_DirectionalLightDirection, vertex.tangentToWorld);

    float3 urand3 = float3(RandomFloat01(rng), RandomFloat01(rng), RandomFloat01(rng));
    // LayeredBRDF brdf = LayeredBRDF::Create(surfaceData, wo.z);
    // float3 rayDirection = brdf.sample(urand3, wo).wi;

    RayDesc ray;
    {
        ray = CreateNewRay(worldPos, 0.0f.xxx, K_T_MIN, K_T_MAX);
    }
    
    PathVertex hitVertex;
    hitVertex.position = worldPos;
    hitVertex.surfaceData = surfaceData;

    vertex.brdf = LayeredBRDF::Create(hitVertex.surfaceData, vertex.wo.z);
    vertex.brdf.ForceDiffuse();
    // invPDF = 1.0;
    uint maxBounceCount = _PT_MaxBounceCount;
    if (RandomFloat01(rng) < 0.25)
    {
        maxBounceCount *= 4;
    }

    [loop]
    for (trace.pathLength = 0; trace.pathLength < maxBounceCount; trace.pathLength++)
    {
        if (!TraceScatterRay(ray, hitVertex, trace, vertex, rng))
        {
            break;
        }

        vertex.tangentToWorld = BuildOrthonormalBasis(hitVertex.surfaceData.normal);

        // To next bounce
        vertex.wo = mul(-ray.Direction, vertex.tangentToWorld);
        if (vertex.wo.z < 0.0)
        {
            vertex.wo.z *= -0.25;
            vertex.wo = normalize(vertex.wo);
        }
        vertex.brdf = LayeredBRDF::Create(hitVertex.surfaceData, vertex.wo.z);
        vertex.brdf.ForceDiffuse();
        vertex.wi = mul(_DirectionalLightDirection, vertex.tangentToWorld);

        TraceShadowRay(hitVertex, trace, vertex);

        [branch]
        if (trace.pathLength == 0)
        {
            trace.firstSampleDir = ray.Direction;
        }


        // Russian roulette

        // if (pathLength >= 2)
        // {
        //     const float rr_coin = RandomFloat01(rng);
        //     const float continue_p = max(hitVertex.surfaceData.albedo.r, max(hitVertex.surfaceData.albedo.g, hitVertex.surfaceData.albedo.b));
        //     if (rr_coin > continue_p)
        //     {
        //         break;
        //     }
        //     else
        //     {
        //         throughput /= continue_p;
        //     }
        // }

    }
    // if (all(trace.radiance >= 0.0))
    // {
    //     totalRadiance += float4(radiance, 1.0);
    // }
    // return totalRadiance.rgb;

}


[shader("raygeneration")]
void PathTracingRayGenShader()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;

    uint rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(_PT_ConvergenceStep + _PT_FrameIndex) * uint(24699)) | uint(1);
    
    TraceData trace;
    VertexData vertex;

    TracePath(launchIndex, launchDim, rng, trace, vertex);

    float3 totalRadiance = trace.radiance;

    if (_PT_Progressive == 0)
    {
        _PT_Output[launchIndex] = float4(totalRadiance, 1);
    }
    else if (_PT_Progressive == 1)
    {
        if (_PT_ConvergenceStep < _PT_MaxFrameCount)
        {
            Reservoir re = UnPack(_TReservoir[launchIndex]);
            re.rand_offset = RandomFloat01(rng);
            re.Update(trace.radiance, re.TargetPDF(trace.radiance), trace.invPDF);
            _TReservoir[launchIndex] = re.Pack(64);
            
            _PT_Output[launchIndex] = float4(re.dir * re.W_sum / (re.M * re.w), 1);
        }

        // re.Update(trace.radiance, re.TargetPDF(lerp(trace.firstLuminance, trace.radiance, 1.0)), trace.invPDF);
        
        // float3 prevRadiance = _PT_Output[launchIndex].xyz;
        // if (_PT_ConvergenceStep < _PT_MaxFrameCount)
        // {
        //     totalRadiance = lerp(prevRadiance, trace.radiance, 1 / float(_PT_ConvergenceStep + 1));
        // }
        // else
        // {
        //     totalRadiance = prevRadiance;
        // }
        // _PT_Output[launchIndex] = float4(totalRadiance, 1);
        // _PT_Output[launchIndex] = float4(totalRadiance, 1);

    }
    else
    {
        if (_PT_ConvergenceStep < _PT_MaxFrameCount)
        {
            float3 prevRadiance = _PT_Output[launchIndex].xyz;
            totalRadiance = lerp(prevRadiance, totalRadiance, 1 / float(_PT_ConvergenceStep + 1));
            _PT_Output[launchIndex] = float4(totalRadiance, 1);
        }
    }
}

[shader("miss")]
void MissShader0_Primary(inout RayPayload payload:SV_RayPayload)
{
    // payload.surfaceData.emission = _PT_EnvTex.SampleLevel(sampler_PT_EnvTex, WorldRayDirection(), 0).rgb;

}

[shader("miss")]
void MissShader1_ShadowRay(inout ShadowRayPayload payload:SV_RayPayload)
{
    payload.isShadowed = false;
}
