#include "UnityShaderVariables.cginc"
#include "../ShaderLibrary/RayPayload.hlsl"
#include "../ShaderLibrary/Utils/RayTracingHelper.hlsl"
#include "../ShaderLibrary/Utils/Random.hlsl"
#include "../ShaderLibrary/Utils/MathConstant.hlsl"
#include "../ShaderLibrary/RayTracingGlobal.hlsl"
#include "../ShaderLibrary/Lighting.hlsl"
#include "../ShaderLibrary/BRDF/BRDF.hlsl"
#include "../ShaderLibrary/rt/RayTrace.hlsl"
#include "../ShaderLibrary/ReSTIR/Reservoir.hlsl"
// #include "../ShaderLibrary/Utils/SpaceTransforms.hlsl"

#pragma max_recursion_depth 10

#define K_USE_ROUGHNESS_BIAS 0

// Ray Tracing Properties
uint _PT_ConvergenceStep;
uint _PT_FrameIndex;
uint _PT_MaxFrameCount;
int _PT_Progressive;

// Camera Properties
float _PT_Zoom;
float _PT_AspectRatio;

// Environment Properties
TextureCube<float4> _PT_EnvTex;
SamplerState sampler_PT_EnvTex;
float _PT_EnvIntensity;

// GBuffers
Texture2D<float4> _GBuffer0;
Texture2D<float4> _GBuffer1;
Texture2D<float4> _GBuffer2;
Texture2D<float4> _GBuffer3;

RWTexture2D<int4> _TReservoir;


void TraceShadowRay(in uint pathLength, in PathVertex hitVertex, in float3 throughput, inout float3 radiance, inout float3 curLuminance, in LayeredBRDF brdf, in float3 wo, in float3 wi)
{
    // Trace shadow ray
    const bool isShadowed = KaiserRayTracer::Create(CreateNewRay(hitVertex.position, _DirectionalLightDirection, 1e-4, K_T_MAX), pathLength, false).TraceShadowRay(_AccelStruct);
    curLuminance = SELECT(isShadowed, 0.0, brdf.evalDirectionalLight(wo, wi) * _DirectionalLightColor);
    radiance += throughput * curLuminance;
}


bool TraceScatterRay(inout RayDesc ray, in uint pathLength, inout uint rng, inout PathVertex hitVertex, inout float3 throughput, inout float3 radiance, inout float invPDF, in LayeredBRDF brdf, in float3 wo, in float3 wi, in float3x3 tangentToWorld)
{
    float3 urand;
    urand = float3(RandomFloat01(rng), RandomFloat01(rng), RandomFloat01(rng));
    
    BRDFSample brdfSample = BRDFSample::Invalid();
    brdfSample = brdf.sample(urand, wo);
    invPDF = 1.0 / brdfSample.pdf;

    if (brdfSample.IsValid())
    {
        ray.Origin = ComputeRayOrigin(hitVertex.position, hitVertex.surfaceData.normal);;
        ray.Direction = mul(tangentToWorld, brdfSample.wi);
        ray.TMin = 1e-4;
        throughput *= brdfSample.weight;
    }
    else
    {
        return false;
    }
    
    hitVertex = KaiserRayTracer::Create(ray, 0, false).TraceScatterRay(_AccelStruct);

    if (!hitVertex.bHit)
    {
        radiance += throughput * _PT_EnvIntensity * _PT_EnvTex.SampleLevel(sampler_PT_EnvTex, ray.Direction, 0).rgb;
        return false;
    }

    // if (dot(hitVertex.surfaceData.normal, ray.Direction) >= 0.0)
    // {
    //     if (0 == pathLength)
    //     {
    //         hitVertex.surfaceData.normal = -hitVertex.surfaceData.normal;
    //     }
    //     else
    //     {
    //         return false;
    //     }
    // }
    radiance += throughput * hitVertex.surfaceData.emission;
    return true;
}


void TracePath(uint2 launchIndex, uint2 launchDim, inout uint rng, inout float3 totalLuminance, inout float3 totalRadiance, inout float3 sampleDir, inout float invPDF)
{
    float2 frameCoord = launchIndex + float2(0.5, 0.5);
    float3 result = float3(0, 0, 0);
    
    // uint rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(_PT_ConvergenceStep + _PT_FrameIndex) * uint(24699)) | uint(1);
    float2 jitter = float2(RandomFloat01(rng), RandomFloat01(rng)) - float2(0.5, 0.5);
    float2 uv = frameCoord / float2(launchDim.x - 1, launchDim.y - 1);
    // float2 uv = (frameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);

    float3 radiance = float3(0, 0, 0);
    float3 throughput = float3(1, 1, 1);
    // float3 totalRadiance = float3(0, 0, 0);

    float3 curLuminance = float3(0, 0, 0);
    // float3 totalLuminance = float3(0, 0, 0);
    
    float3 albedo = _GBuffer0.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 normal = _GBuffer1.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 worldPos = _GBuffer2.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 rmao = _GBuffer3.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float roughness = rmao.x;
    float metallic = rmao.y;

    SurfaceData surfaceData;
    surfaceData.albedo = albedo;
    surfaceData.normal = normal;
    surfaceData.emission = float3(0, 0, 0);
    // surfaceData.roughness = roughness;
    // surfaceData.metallic = metallic;
    surfaceData.roughness = 0.999;
    surfaceData.metallic = 0.001;

    float3 viewDir = normalize(_WorldSpaceCameraPos - worldPos);
    float3x3 tangentToWorld = BuildOrthonormalBasis(surfaceData.normal);
    float3 wo = mul(viewDir, tangentToWorld);
    float3 wi = mul(_DirectionalLightDirection, tangentToWorld);

    float3 urand3 = float3(RandomFloat01(rng), RandomFloat01(rng), RandomFloat01(rng));
    LayeredBRDF brdf = LayeredBRDF::Create(surfaceData, wo.z);
    // float3 rayDirection = brdf.sample(urand3, wo).wi;
    float3 rayDirection = 0.0f.xxx;
    
    RayDesc ray;
    {
        ray = CreateNewRay(worldPos, rayDirection, K_T_MIN, K_T_MAX);
    }
    
    PathVertex hitVertex;
    hitVertex.position = worldPos;
    hitVertex.surfaceData = surfaceData;

    VertexTraceData vertexData;

    // invPDF = 1.0;

    [loop]
    for (uint pathLength = 0; pathLength < _PT_MaxBounceCount; pathLength++)
    {
        LayeredBRDF brdf = LayeredBRDF::Create(hitVertex.surfaceData, wo.z);

        if (!TraceScatterRay(ray, pathLength, rng, hitVertex, throughput, radiance, invPDF, brdf, wo, wi, tangentToWorld))
        {
            break;
        }

        tangentToWorld = BuildOrthonormalBasis(hitVertex.surfaceData.normal);

        // To next bounce
        wo = mul(-ray.Direction, tangentToWorld);
        if (wo.z < 0.0)
        {
            wo.z *= -0.25;
            wo = normalize(wo);
        }
        brdf = LayeredBRDF::Create(hitVertex.surfaceData, wo.z);
        
        wi = mul(_DirectionalLightDirection, tangentToWorld);

        TraceShadowRay(pathLength, hitVertex, throughput, radiance, curLuminance, brdf, wo, wi);

        [branch]
        if (pathLength == 0)
        {
            totalLuminance += max(0.0f, curLuminance);
            sampleDir = ray.Direction;
        }


        // Russian roulette

        // if (pathLength >= 2)
        // {
        //     const float rr_coin = RandomFloat01(rng);
        //     const float continue_p = max(hitVertex.surfaceData.albedo.r, max(hitVertex.surfaceData.albedo.g, hitVertex.surfaceData.albedo.b));
        //     if (rr_coin > continue_p)
        //     {
        //         break;
        //     }
        //     else
        //     {
        //         throughput /= continue_p;
        //     }
        // }

    }
    if (all(radiance >= 0.0))
    {
        totalRadiance += float4(radiance, 1.0);
    }
    // return totalRadiance.rgb;

}


[shader("raygeneration")]
void PathTracingRayGenShader()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;

    float3 totalLuminance = float3(0, 0, 0);
    float3 totalRadiance = float3(0, 0, 0);
    float3 sampleDir = float3(0, 0, 0);
    float invPDF = 1.0;

    uint rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(_PT_ConvergenceStep + _PT_FrameIndex) * uint(24699)) | uint(1);
    
    TracePath(launchIndex, launchDim, rng, totalLuminance, totalRadiance, sampleDir);

    if (_PT_Progressive == 0)
    {
        _PT_Output[launchIndex] = float4(totalRadiance, 1);
    }
    else if (_PT_Progressive == 1)
    {
        Reservoir re = UnPack(_TReservoir[launchIndex]);
        re.rand_offset = RandomFloat01(rng);
        
        re.Update(dir, re.TargetPDF(lerp(totalLuminance, radiance, 0.0)), invPDF);
        float3 prevRadiance = _PT_Output[launchIndex].xyz;
        if (_PT_ConvergenceStep < _PT_MaxFrameCount)
        {
            totalRadiance = lerp(prevRadiance, totalRadiance, 1 / float(_PT_ConvergenceStep + 1));
        }
        else
        {
            totalRadiance = prevRadiance;
        }
        _PT_Output[launchIndex] = float4(totalRadiance, 1);
    }
    else
    {
        float3 prevRadiance = _PT_Output[launchIndex].xyz;
        totalRadiance = lerp(prevRadiance, totalRadiance, 1 / float(_PT_ConvergenceStep + 1));
        _PT_Output[launchIndex] = float4(totalRadiance, 1);
    }
}

[shader("miss")]
void MissShader0_Primary(inout RayPayload payload:SV_RayPayload)
{
    // payload.surfaceData.emission = _PT_EnvTex.SampleLevel(sampler_PT_EnvTex, WorldRayDirection(), 0).rgb;

}

[shader("miss")]
void MissShader1_ShadowRay(inout ShadowRayPayload payload:SV_RayPayload)
{
    payload.isShadowed = false;
}
