#include "UnityShaderVariables.cginc"
#include "../ShaderLibrary/RayPayload.hlsl"
#include "../ShaderLibrary/Utils/RayTracingHelper.hlsl"
#include "../ShaderLibrary/Utils/Random.hlsl"
#include "../ShaderLibrary/Utils/MathConstant.hlsl"
#include "../ShaderLibrary/RayTracingGlobal.hlsl"
#include "../ShaderLibrary/Lighting.hlsl"
#include "../ShaderLibrary/BRDF/BRDF.hlsl"
#include "../ShaderLibrary/rt/RayTrace.hlsl"
#include "../ShaderLibrary/ReSTIR/Reservoir.hlsl"
// #include "../ShaderLibrary/Utils/SpaceTransforms.hlsl"

#pragma max_recursion_depth 10

#define K_USE_ROUGHNESS_BIAS 0

// Ray Tracing Properties
uint _RE_ConvergenceStep;
uint _RE_FrameIndex;
uint _RE_MaxBounceCount;
int _RE_ResSTIRType;
int _RE_TReservoirSize;
int _RE_SReservoirSize;
int _RE_LongPath;

int _RE_EvaluateDirectLighting;

// Camera Properties
float _RE_Zoom;
float _RE_AspectRatio;

// Environment Properties
TextureCube<float4> _RE_EnvTex;
SamplerState sampler_RE_EnvTex;
float _RE_EnvIntensity;

// GBuffers
Texture2D<float4> _GBuffer0;
Texture2D<float4> _GBuffer1;
Texture2D<float4> _GBuffer2;
Texture2D<float4> _GBuffer3;

RWTexture2D<int4> _TReservoir;
RWTexture2D<int4> _SReservoir;


float3 EvaluateDirectLight(in PathVertex hitVertex, inout TraceData trace, inout VertexData vertex)
{
    // Trace shadow ray
    const bool isShadowed = KaiserRayTracer::Create(CreateNewRay(hitVertex.position, _DirectionalLightDirection, 1e-4, K_T_MAX), trace.pathLength, false).TraceShadowRay(_AccelStruct);
    return trace.throughput * SELECT(isShadowed, 0.0, vertex.brdf.evalDirectionalLight(vertex.wo, vertex.wi) * _DirectionalLightColor);
}

void TraceShadowRay(in PathVertex hitVertex, inout TraceData trace, inout VertexData vertex)
{
    // Trace shadow ray
    const bool isShadowed = KaiserRayTracer::Create(CreateNewRay(hitVertex.position, _DirectionalLightDirection, 1e-4, K_T_MAX), trace.pathLength, false).TraceShadowRay(_AccelStruct);
    trace.firstLuminance = SELECT(isShadowed, 0.0, vertex.brdf.evalDirectionalLight(vertex.wo, vertex.wi) * _DirectionalLightColor);
    trace.radiance += trace.throughput * trace.firstLuminance;
}


bool TraceScatterRay(inout RayDesc ray, inout PathVertex hitVertex, inout TraceData trace, inout VertexData vertex, inout uint rng)
{
    float3 urand;
    urand = float3(RandomFloat01(rng), RandomFloat01(rng), RandomFloat01(rng));
    
    BRDFSample brdfSample = BRDFSample::Invalid();
    brdfSample = vertex.brdf.sample(urand, vertex.wo);

    if (brdfSample.IsValid())
    {
        ray.Origin = ComputeRayOrigin(hitVertex.position, hitVertex.surfaceData.normal);;
        ray.Direction = mul(vertex.tangentToWorld, brdfSample.wi);
        ray.TMin = 1e-4;
        trace.throughput *= brdfSample.weight;
        trace.invPDF = 1.0f / brdfSample.pdf;
    }
    else
    {
        trace.invPDF = 0.0f;
        return false;
    }
    
    hitVertex = KaiserRayTracer::Create(ray, 0, false).TraceScatterRay(_AccelStruct);

    if (!hitVertex.bHit)
    {
        trace.radiance += trace.throughput * _RE_EnvIntensity * _RE_EnvTex.SampleLevel(sampler_RE_EnvTex, ray.Direction, 0).rgb;
        return false;
    }

    if (dot(hitVertex.surfaceData.normal, ray.Direction) >= 0.0)
    {
        if (0 == trace.pathLength)
        {
            hitVertex.surfaceData.normal = -hitVertex.surfaceData.normal;
        }
        else
        {
            return false;
        }
    }
    trace.radiance += trace.throughput * hitVertex.surfaceData.emission;
    return true;
}


void TracePath(uint2 launchIndex, uint2 launchDim, inout uint rng, inout TraceData trace, inout VertexData vertex, out float3 directRadiance)
{
    float2 frameCoord = launchIndex + float2(0.5, 0.5);
    float3 result = float3(0, 0, 0);
    
    // uint rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(_RE_ConvergenceStep + _RE_FrameIndex) * uint(24699)) | uint(1);
    float2 jitter = float2(RandomFloat01(rng), RandomFloat01(rng)) - float2(0.5, 0.5);
    // float2 uv = frameCoord / float2(launchDim.x - 1, launchDim.y - 1);
    float2 uv = (frameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);

    float3 albedo = _GBuffer0.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 normal = _GBuffer1.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 worldPos = _GBuffer2.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 rmao = _GBuffer3.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float roughness = rmao.x;
    float metallic = rmao.y;

    SurfaceData surfaceData;
    surfaceData.albedo = albedo;
    surfaceData.normal = normal;
    surfaceData.emission = float3(0, 0, 0);
    surfaceData.roughness = roughness;
    surfaceData.metallic = metallic;
    // surfaceData.roughness = 1;
    // surfaceData.metallic = 0;

    // if (roughness > 0.4)
    // {
    //     return;
    // }

    surfaceData.metallic = metallic;
    trace.pathLength = 0;
    trace.throughput = albedo;
    trace.radiance = float3(0, 0, 0);
    trace.firstLuminance = float3(0, 0, 0);

    float3 viewDir = normalize(_WorldSpaceCameraPos - worldPos);

    vertex.tangentToWorld = BuildOrthonormalBasis(surfaceData.normal);
    vertex.wo = mul(viewDir, vertex.tangentToWorld);
    vertex.wi = mul(_DirectionalLightDirection, vertex.tangentToWorld);

    float3 urand3 = float3(RandomFloat01(rng), RandomFloat01(rng), RandomFloat01(rng));
    // LayeredBRDF brdf = LayeredBRDF::Create(surfaceData, wo.z);
    // float3 rayDirection = brdf.sample(urand3, wo).wi;

    RayDesc ray;
    {
        ray = CreateNewRay(worldPos, 0.0f.xxx, K_T_MIN, K_T_MAX);
    }
    
    PathVertex hitVertex;
    hitVertex.position = worldPos;
    hitVertex.surfaceData = surfaceData;

    vertex.brdf = LayeredBRDF::Create(hitVertex.surfaceData, vertex.wo.z);
    // vertex.brdf.ForceDiffuse();

    directRadiance = float3(0, 0, 0);
    // if (_RE_EvaluateDirectLighting)

    {
        directRadiance = EvaluateDirectLight(hitVertex, trace, vertex);
    }
    

    // invPDF = 1.0;
    uint maxBounceCount = _RE_MaxBounceCount;

    [branch]
    if (_RE_LongPath && RandomFloat01(rng) < 0.25)
    {
        maxBounceCount *= 4;
    }

    [loop]
    for (trace.pathLength = 0; trace.pathLength < maxBounceCount; trace.pathLength++)
    {
        if (!TraceScatterRay(ray, hitVertex, trace, vertex, rng))
        {
            break;
        }

        vertex.tangentToWorld = BuildOrthonormalBasis(hitVertex.surfaceData.normal);

        // To next bounce
        vertex.wo = mul(-ray.Direction, vertex.tangentToWorld);
        if (vertex.wo.z < 0.0)
        {
            vertex.wo.z *= -0.25;
            vertex.wo = normalize(vertex.wo);
        }
        vertex.brdf = LayeredBRDF::Create(hitVertex.surfaceData, vertex.wo.z);
        // vertex.brdf.ForceDiffuse();
        vertex.wi = mul(_DirectionalLightDirection, vertex.tangentToWorld);

        TraceShadowRay(hitVertex, trace, vertex);

        [branch]
        if (trace.pathLength == 0)
        {
            trace.firstSampleDir = ray.Direction;
        }


        // Russian roulette

        // if (pathLength >= 2)
        // {
        //     const float rr_coin = RandomFloat01(rng);
        //     const float continue_p = max(hitVertex.surfaceData.albedo.r, max(hitVertex.surfaceData.albedo.g, hitVertex.surfaceData.albedo.b));
        //     if (rr_coin > continue_p)
        //     {
        //         break;
        //     }
        //     else
        //     {
        //         throughput /= continue_p;
        //     }
        // }

    }
    // if (all(trace.radiance >= 0.0))
    // {
    //     totalRadiance += float4(radiance, 1.0);
    // }
    // return totalRadiance.rgb;

}


[shader("raygeneration")]
void ReSTIR_Temporal()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;

    uint rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(_RE_ConvergenceStep + _RE_FrameIndex) * uint(24699)) | uint(1);
    
    TraceData trace;
    VertexData vertex;
    float3 directRadiance;
    TracePath(launchIndex, launchDim, rng, trace, vertex, directRadiance);

    float3 totalRadiance = trace.radiance;

    if (_RE_ResSTIRType == 0)
    {
        _Output[launchIndex] = float4(totalRadiance, 1);
    }
    else
    {
        // if (_RE_ConvergenceStep < _RE_MaxFrameCount)

        {
            Reservoir re;
            if (_RE_ResSTIRType == 1)
            {
                re = UnPack(_TReservoir[launchIndex]);
            }
            else
            {
                re = UnPack(_SReservoir[launchIndex]);
            }

            // trace.radiance = saturate(trace.radiance);clamp(trace.invPDF, 0, 5000.0f)
            re.Update(trace.firstSampleDir, trace.radiance, re.TargetPDF(trace.radiance), clamp(trace.invPDF, 0, 256), RandomFloat01(rng));
            // re.Update(trace.radiance, trace.firstSampleDir, re.TargetPDF(trace.radiance), trace.invPDF, RandomFloat01(rng));
            _TReservoir[launchIndex] = re.Pack(_RE_TReservoirSize);
            
            // _Output[launchIndex] = float4(re.wSum.xxx / re.w / 100, 1.0f);
            _Output[launchIndex] = float4(re.radiance * re.wSum / (re.M * re.w), 1.0f);
        }
    }
}

[shader("raygeneration")]
void ReSTIR_Spatial()
{
    uint2 launchIndex = DispatchRaysIndex().xy;
    uint2 launchDim = DispatchRaysDimensions().xy;

    uint rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(_RE_ConvergenceStep + _RE_FrameIndex) * uint(24699)) | uint(1);
    float2 frameCoord = launchIndex + float2(0.5, 0.5);

    float2 jitter = float2(RandomFloat01(rng), RandomFloat01(rng)) - float2(0.5, 0.5);
    // float2 uv = frameCoord / float2(launchDim.x - 1, launchDim.y - 1);
    float2 uv = (frameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);

    float3 albedo = _GBuffer0.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 normal = _GBuffer1.SampleLevel(sampler_point_clamp, uv, 0).xyz;
    float3 worldPos = _GBuffer2.SampleLevel(sampler_point_clamp, uv, 0).xyz;

    float2 offset = float2(RandomFloat01(rng), RandomFloat01(rng));

    Reservoir re = UnPack(_TReservoir[launchIndex]);
    // _Output[launchIndex] = float4(re.radiance * re.wSum / (re.M * re.w), 1.0f);
    float radi = 64;
    int maxSpatialSample = 2;
    float2 neighbourFrameCoord;
    float2 neighbourUV;
    float3 neighbourWorldPos;
    float3 neighbourNormal;
    int sample = 0;
    for (int i = 0; i < maxSpatialSample; i++)
    {
        rng = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(_RE_ConvergenceStep + _RE_FrameIndex + uint(i)) * uint(24699)) | uint(1);
        
        float2 s = radi * SampleDiskConcentric(frac(float2(RandomFloat01(rng), RandomFloat01(rng)) + offset));
        Reservoir neighbour = UnPack(_TReservoir[launchIndex + round(s)]);

        neighbourFrameCoord = launchIndex + round(s) + float2(0.5, 0.5);
        neighbourUV = (neighbourFrameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);
        neighbourWorldPos = _GBuffer2.SampleLevel(sampler_point_clamp, neighbourUV, 0).xyz;
        neighbourNormal = _GBuffer1.SampleLevel(sampler_point_clamp, neighbourUV, 0).xyz;

        if (distance(neighbourWorldPos, worldPos) > 1.1f) continue;
        if (dot(neighbourNormal, normal) < 0.1f) continue;
        // neighbour.RescaleTo(16);
        // if (dot(neighbour.dir, normal) < 0.1f || luminance(neighbour.radiance) <= 0.001f) continue;
        re.Update(neighbour, RandomFloat01(rng));

        sample++;
    }

    _SReservoir[launchIndex] = re.Pack(_RE_SReservoirSize);
    _Output[launchIndex] = float4(re.radiance * re.wSum / (re.M * re.w), 1.0f);
    // _Output[launchIndex] = sample / float(maxSpatialSample);

}





[shader("miss")]
void MissShader0_Primary(inout RayPayload payload:SV_RayPayload)
{
    // payload.surfaceData.emission = _RE_EnvTex.SampleLevel(sampler_RE_EnvTex, WorldRayDirection(), 0).rgb;

}

[shader("miss")]
void MissShader1_ShadowRay(inout ShadowRayPayload payload:SV_RayPayload)
{
    payload.isShadowed = false;
}
